<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaScript, Java">
    <meta name="description" content="up up up">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaScript | CR553</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">CR553</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">CR553</div>
        <div class="logo-desc">
            
            up up up
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/CR553?tab=repositories" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/CR553?tab=repositories" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaScript</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-16
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h2><p>如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p>
<pre><code>i = 10; // i现在是全局变量</code></pre><p>在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<pre><code>&#39;use strict&#39;;</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>JavaScript的字符串就是用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的字符表示。</p>
<p>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p>
<pre><code>&#39;I\&#39;m \&quot;OK\&quot;!&#39;;</code></pre><p>表示的字符串内容是：<code>I&#39;m &quot;OK&quot;!</code></p>
<p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ** … ** 表示：</p>
<pre><code>`这是一个
多行
字符串`;</code></pre><p>ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<pre><code>var name = &#39;小明&#39;;
var age = 20;
var message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);</code></pre><h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><p><em>需要特别注意的是</em>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
<pre><code>var s = &#39;Test&#39;;
s[0] = &#39;X&#39;;
alert(s); /</code></pre><h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h3><p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<pre><code>var s = &#39;Hello&#39;;
s.toUpperCase(); // 返回&#39;HELLO&#39;</code></pre><h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h3><p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<pre><code>var s = &#39;Hello&#39;;
var lower = s.toLowerCase(); // 返回&#39;hello&#39;并赋值给变量lower
lower; // &#39;hello&#39;</code></pre><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><code>indexOf()</code>会搜索指定字符串出现的位置：</p>
<pre><code>var s = &#39;hello, world&#39;;
s.indexOf(&#39;world&#39;); // 返回7
s.indexOf(&#39;World&#39;); // 没有找到指定的子串，返回-1</code></pre><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p><code>substring()</code>返回指定索引区间的子串：</p>
<pre><code>var s = &#39;hello, world&#39;
s.substring(0, 5); // 从索引0开始到5（不包括5），返回&#39;hello&#39;
s.substring(7); // 从索引7开始到结束，返回&#39;world&#39;</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>JavaScript的<code>Array</code>可以包含任意数据类型，并通过索引来访问每个元素。</p>
<p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p>
<pre><code>var arr = [1, 2, 3.14, &#39;Hello&#39;, null, true];
arr.length; // 6</code></pre><p><em>请注意</em>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p>
<pre><code>var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]</code></pre><p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
arr[1] = 99;
arr; // arr现在变为[&#39;A&#39;, 99, &#39;C&#39;]</code></pre><p><em>请注意</em>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<pre><code>var arr = [1, 2, 3];
arr[5] = &#39;x&#39;;
arr; // arr变为[1, 2, 3, undefined, undefined, &#39;x&#39;]</code></pre><h3 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf"></a>indexOf</h3><p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<pre><code>var arr = [10, 20, &#39;30&#39;, &#39;xyz&#39;];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf(&#39;30&#39;); // 元素&#39;30&#39;的索引为2</code></pre><p>注意了，数字<code>30</code>和字符串<code>&#39;30&#39;</code>是不同的元素。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
arr.slice(3); // 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</code></pre><p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];
var aCopy = arr.slice();
aCopy; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]
aCopy === arr; // false</code></pre><h3 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h3><p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<pre><code>var arr = [1, 2];
arr.push(&#39;A&#39;, &#39;B&#39;); // 返回Array新的长度: 4
arr; // [1, 2, &#39;A&#39;, &#39;B&#39;]
arr.pop(); // pop()返回&#39;B&#39;
arr; // [1, 2, &#39;A&#39;]
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []</code></pre><h3 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h3><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<pre><code>var arr = [1, 2];
arr.unshift(&#39;A&#39;, &#39;B&#39;); // 返回Array新的长度: 4
arr; // [&#39;A&#39;, &#39;B&#39;, 1, 2]
arr.shift(); // &#39;A&#39;
arr; // [&#39;B&#39;, 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>
<pre><code>var arr = [&#39;B&#39;, &#39;C&#39;, &#39;A&#39;];
arr.sort();
arr; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre><p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转：</p>
<pre><code>var arr = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];
arr.reverse(); 
arr; // [&#39;three&#39;, &#39;two&#39;, &#39;one&#39;]</code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<pre><code>var arr = [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); // 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]
// 只删除,不添加:
arr.splice(2, 2); // [&#39;Google&#39;, &#39;Facebook&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]
// 只添加,不删除:
arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); // 返回[],因为没有删除任何元素
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</code></pre><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var added = arr.concat([1, 2, 3]);
added; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3]
arr; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre><p><em>请注意</em>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
arr.concat(1, 2, [3, 4]); // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, 4]</code></pre><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3];
arr.join(&#39;-&#39;); // &#39;A-B-C-1-2-3&#39;</code></pre><p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>如果数组的某个元素又是一个<code>Array</code>，则可以形成多维数组，例如：</p>
<pre><code>var arr = [[1, 2, 3], [400, 500, 600], &#39;-&#39;];</code></pre><p>上述<code>Array</code>包含3个元素，其中头两个元素本身也是<code>Array</code>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成</p>
<pre><code>var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    school: &#39;No.1 Middle School&#39;,
    height: 1.70,
    weight: 65,
    score: null
};</code></pre><p>JavaScript用一个<code>{...}</code>表示一个对象，键值对以<code>xxx: xxx</code>形式申明，用<code>,</code>隔开。注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<pre><code>var xiaohong = {
    name: &#39;小红&#39;,
    &#39;middle-school&#39;: &#39;No.1 Middle School&#39;
};</code></pre><p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<pre><code>xiaohong[&#39;middle-school&#39;]; // &#39;No.1 Middle School&#39;
xiaohong[&#39;name&#39;]; // &#39;小红&#39;
xiaohong.name; // &#39;小红&#39;</code></pre><p>也可以用<code>xiaohong[&#39;name&#39;]</code>来访问<code>xiaohong</code>的<code>name</code>属性，不过<code>xiaohong.name</code>的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过<code>object.prop</code>的形式访问一个属性了。</p>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<pre><code>var xiaoming = {
    name: &#39;小明&#39;
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming[&#39;name&#39;]; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错</code></pre><p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<pre><code>var xiaoming = {
    name: &#39;小明&#39;
};
xiaoming.hasOwnProperty(&#39;name&#39;); // true
xiaoming.hasOwnProperty(&#39;toString&#39;); // false</code></pre><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>JavaScript使用<code>if () { ... } else { ... }</code>来进行条件判断。例如，根据年龄显示不同内容，可以用<code>if</code>语句实现如下：</p>
<pre><code>var age = 20;
if (age &gt;= 18) { // 如果age &gt;= 18为true，则执行if语句块
    alert(&#39;adult&#39;);
} else { // 否则执行else语句块
    alert(&#39;teenager&#39;);
}</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>for</code>循环最常用的地方是利用索引来遍历数组：</p>
<pre><code>var arr = [&#39;Apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;];
var i, x;
for (i=0; i&lt;arr.length; i++) {
    x = arr[i];
    console.log(x);
}</code></pre><p><code>for</code>循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用<code>break</code>语句退出循环，否则就是死循环：</p>
<pre><code>var x = 0;
for (;;) { // 将无限循环下去
    if (x &gt; 100) {
        break; // 通过if判断来退出循环
    }
    x ++;
}</code></pre><p><code>while</code>循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<pre><code>var x = 0;
var n = 99;
while (n &gt; 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500</code></pre><h2 id="Map和Sert"><a href="#Map和Sert" class="headerlink" title="Map和Sert"></a>Map和Sert</h2><p>JavaScript的默认对象表示方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<pre><code>var m = new Map(); // 空Map
m.set(&#39;Adam&#39;, 67); // 添加新的key-value
m.set(&#39;Bob&#39;, 59);
m.has(&#39;Adam&#39;); // 是否存在key &#39;Adam&#39;: true
m.get(&#39;Adam&#39;); // 67
m.delete(&#39;Adam&#39;); // 删除key &#39;Adam&#39;
m.get(&#39;Adam&#39;); // undefined</code></pre><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<pre><code>var m = new Map();
m.set(&#39;Adam&#39;, 67);
m.set(&#39;Adam&#39;, 88);
m.get(&#39;Adam&#39;); // 88</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3</code></pre><p>重复元素在<code>Set</code>中自动被过滤：</p>
<pre><code>var s = new Set([1, 2, 3, 3, &#39;3&#39;]);
s; // Set {1, 2, 3, &quot;3&quot;}</code></pre><p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<pre><code>s.add(4);
s; // Set {1, 2, 3, 4}
s.add(4);
s; // 仍然是 Set {1, 2, 3, 4}</code></pre><p>通过<code>delete(key)</code>方法可以删除元素：</p>
<pre><code>var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}</code></pre><h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<pre><code>var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + &#39;=&#39; + x[1]);
}</code></pre><p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<pre><code>&#39;use strict&#39;; var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; </code></pre><pre><code>a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    console.log(element + &#39;, index = &#39; + index);
});</code></pre><p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<pre><code>var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
s.forEach(function (element, sameElement, set) {
    console.log(element);
});</code></pre><p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<pre><code>var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
m.forEach(function (value, key, map) {
    console.log(value);
});</code></pre><p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<pre><code>var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
a.forEach(function (element) {
    console.log(element);
});</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在JavaScript中，定义函数的方式如下：</p>
<pre><code>function abs(x) {
    if (x &gt;= 0) {
        return x;
    } else {
        return -x;
    }
}</code></pre><p>上述<code>abs()</code>函数的定义如下：</p>
<ul>
<li><code>function</code>指出这是一个函数定义；</li>
<li><code>abs</code>是函数的名称；</li>
<li><code>(x)</code>括号内列出函数的参数，多个参数以<code>,</code>分隔；</li>
<li><code>{ ... }</code>之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ul>
<p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>undefined</code>。</p>
<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>
<p>因此，第二种定义函数的方式如下：</p>
<pre><code>var abs = function (x) {
    if (x &gt;= 0) {
        return x;
    } else {
        return -x;
    }
};</code></pre><p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>
<p>上述两种定义<em>完全等价</em>，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：</p>
<pre><code>function foo(x) {
    console.log(&#39;x = &#39; + x); // 10
    for (var i=0; i&lt;arguments.length; i++) {
        console.log(&#39;arg &#39; + i + &#39; = &#39; + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
</code></pre><p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p>
<pre><code>function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x &gt;= 0 ? x : -x;
}

abs(); // 0
abs(10); // 10
abs(-9); // 9</code></pre><p>实际上<code>arguments</code>最常用于判断传入参数的个数。你可能会看到这样的写法：</p>
<pre><code>// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}</code></pre><p>要把中间的参数<code>b</code>变为“可选”参数，就只能通过<code>arguments</code>判断，然后重新调整参数并赋值。</p>
<p>ES6标准引入了rest参数，上面的函数可以改写为：</p>
<pre><code>function foo(a, b, ...rest) {
    console.log(&#39;a = &#39; + a);
    console.log(&#39;b = &#39; + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []</code></pre><p>rest参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是<code>undefined</code>）。</p>
<h3 id="变量作用与解构赋值"><a href="#变量作用与解构赋值" class="headerlink" title="变量作用与解构赋值"></a>变量作用与解构赋值</h3><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
<pre><code>&#39;use strict&#39;;

function foo() {
    var x = &#39;Hello, &#39; + y;
    console.log(x);
    var y = &#39;Bob&#39;;
}

foo();</code></pre><p>虽然是strict模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>console.log</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>
<p>对于上述<code>foo()</code>函数，JavaScript引擎看到的代码相当于：</p>
<pre><code>function foo() {
    var y; // 提升变量y的申明，此时y为undefined
    var x = &#39;Hello, &#39; + y;
    console.log(x);
    y = &#39;Bob&#39;;
}</code></pre><p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个<code>var</code>申明函数内部用到的所有变量：</p>
<pre><code>function foo() {
    var
        x = 1, // x初始化为1
        y = x + 1, // y初始化为2
        z, i; // z和i为undefined
    // 其他语句:
    for (i=0; i&lt;100; i++) {
        ...
    }
}</code></pre><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量实际上被绑定到<code>window</code>的一个属性：</p>
<p>JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。</p>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<pre><code>// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &#39;myapp&#39;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &#39;foo&#39;;
};</code></pre><p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。</p>
<p>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的：</p>
<pre><code>&#39;use strict&#39;;

function foo() {
    for (var i=0; i&lt;100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}</code></pre><p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：</p>
<pre><code>&#39;use strict&#39;;

function foo() {
    var sum = 0;
    for (let i=0; i&lt;100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}</code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>由于<code>var</code>和<code>let</code>申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
<pre><code>var PI = 3.14;</code></pre><p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：</p>
<pre><code>&#39;use strict&#39;;

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14</code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。</p>
<p>什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：</p>
<pre><code>var array = [&#39;hello&#39;, &#39;JavaScript&#39;, &#39;ES6&#39;];
var x = array[0];
var y = array[1];
var z = array[2];</code></pre><p>现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值：</p>
<pre><code>&#39;use strict&#39;;  // 如果浏览器支持解构赋值就不会报错: var [x, y, z] = [&#39;hello&#39;, &#39;JavaScript&#39;, &#39;ES6&#39;];</code></pre><p>如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：</p>
<pre><code>let [x, [y, z]] = [&#39;hello&#39;, [&#39;JavaScript&#39;, &#39;ES6&#39;]];
x; // &#39;hello&#39;
y; // &#39;JavaScript&#39;
z; // &#39;ES6&#39;</code></pre><p>解构赋值还可以忽略某些元素：</p>
<pre><code>let [, , z] = [&#39;hello&#39;, &#39;JavaScript&#39;, &#39;ES6&#39;]; // 忽略前两个元素，只对z赋值第三个元素
z; // &#39;ES6&#39;</code></pre><p>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：</p>
<pre><code>&#39;use strict&#39;; 
var person = {    
name: &#39;小明&#39;,
age: 20,     
gender: &#39;male&#39;,     
passport: &#39;G-12345678&#39;,     
school: &#39;No.4 middle school&#39;
}; 
var {name, age, passport} = person;</code></pre><pre><code>var person = {
    name: &#39;小明&#39;,
    age: 20,
    gender: &#39;male&#39;,
    passport: &#39;G-12345678&#39;,
    school: &#39;No.4 middle school&#39;,
    address: {
        city: &#39;Beijing&#39;,
        street: &#39;No.1 Road&#39;,
        zipcode: &#39;100001&#39;
    }
};
var {name, address: {city, zip}} = person;
name; // &#39;小明&#39;
city; // &#39;Beijing&#39;
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined</code></pre><p>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为<code>undefined</code>，这和引用一个不存在的属性获得<code>undefined</code>是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：</p>
<pre><code>var person = {
    name: &#39;小明&#39;,
    age: 20,
    gender: &#39;male&#39;,
    passport: &#39;G-12345678&#39;,
    school: &#39;No.4 middle school&#39;
};

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // &#39;小明&#39;
id; // &#39;G-12345678&#39;
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined</code></pre><p>解构赋值还可以使用默认值，这样就避免了不存在的属性返回<code>undefined</code>的问题：</p>
<pre><code>var person = {
    name: &#39;小明&#39;,
    age: 20,
    gender: &#39;male&#39;,
    passport: &#39;G-12345678&#39;
};

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // &#39;小明&#39;
single; // true</code></pre><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>解构赋值在很多时候可以大大简化代码。例如，交换两个变量<code>x</code>和<code>y</code>的值，可以这么写，不再需要临时变量：</p>
<pre><code>var x=1, y=2;
[x, y] = [y, x]</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在一个对象中绑定函数，称为这个对象的方法。</p>
<pre><code>&#39;use strict&#39;;

var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25
用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>虽然在一个独立的函数调用中，根据是否是strict模式，<code>this</code>指向<code>undefined</code>或<code>window</code>，不过，我们还是可以控制<code>this</code>的指向的！</p>
<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>
<p>用<code>apply</code>修复<code>getAge()</code>调用：</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空</code></pre><p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><code>call()</code>把参数按顺序传入。</li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<pre><code>Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5</code></pre><p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：</p>
<pre><code>&#39;use strict&#39;;  var count = 0; var oldParseInt = parseInt; // 保存原函数  window.parseInt = function () {     count += 1;     return oldParseInt.apply(null, arguments); // 调用原函数 };</code></pre><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数英文叫Higher-order function。那么什么是高阶函数？</p>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<pre><code>function add(x, y, f) {
    return f(x) + f(y);
}</code></pre><p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<pre><code>x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;
return 11;</code></pre><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>由于<code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：</p>
<pre><code>&#39;use strict&#39;; 
function pow(x) {     return x * x; }</code></pre><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
console.log(results);</code></pre><p>所以，<code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把<code>Array</code>的所有数字转为字符串：</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String); // [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</code></pre><p>只需要一行代码。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>要把<code>[1, 3, 5, 7, 9]</code>变换成整数13579，<code>reduce()</code>也能派上用场：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579</code></pre><h4 id="fillter"><a href="#fillter" class="headerlink" title="fillter"></a>fillter</h4><p>filter也是一个常用的操作，它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：</p>
<pre><code>var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]</code></pre><p>把一个<code>Array</code>中的空字符串删掉，可以这么写：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, null, undefined, &#39;C&#39;, &#39;  &#39;];
var r = arr.filter(function (s) {
    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre><p>可见用<code>filter()</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p><code>filter()</code>接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示<code>Array</code>的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>
<pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 依次打印&#39;A&#39;, &#39;B&#39;, &#39;C&#39;
    console.log(index); // 依次打印0, 1, 2
    console.log(self); // self就是变量arr
    return true;
});</code></pre><p>利用<code>filter</code>，可以巧妙地去除<code>Array</code>的重复元素：</p>
<pre><code>&#39;use strict&#39;;
var     r,   
arr = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;strawberry&#39;]; </code></pre><pre><code>r = arr.filter(function (element, index, self) {
    return self.indexOf(element) === index;
});</code></pre><p>去除重复元素依靠的是<code>indexOf</code>总是返回第一个元素的位置，后续的重复元素位置与<code>indexOf</code>返回的位置不相等，因此被<code>filter</code>滤掉了。</p>
<h4 id="sort-1"><a href="#sort-1" class="headerlink" title="sort"></a>sort</h4><pre><code>&#39;use strict&#39;;

var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &lt; y) {
        return -1;
    }
    if (x &gt; y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]</code></pre><pre><code>如果要倒序排序，我们可以把大的数放前面：
var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &lt; y) {
        return 1;
    }
    if (x &gt; y) {
        return -1;
    }
    return 0;
}); // [20, 10, 2, 1]</code></pre><pre><code>var arr = [&#39;Google&#39;, &#39;apple&#39;, &#39;Microsoft&#39;];
arr.sort(function (s1, s2) {
    x1 = s1.toUpperCase();
    x2 = s2.toUpperCase();
    if (x1 &lt; x2) {
        return -1;
    }
    if (x1 &gt; x2) {
        return 1;
    }
    return 0;
}); // [&#39;apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;]</code></pre><p>忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><p><code>every()</code>方法可以判断数组的所有元素是否满足测试条件。</p>
<p>例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：</p>
<pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];
console.log(arr.every(function (s) {
    return s.length &gt; 0;
})); // true, 因为每个元素都满足s.length&gt;0

console.log(arr.every(function (s) {
    return s.toLowerCase() === s;
})); // false, 因为不是每个元素都全部是小写
</code></pre><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find()</code>方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回<code>undefined</code>：</p>
<pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];
console.log(arr.find(function (s) {
    return s.toLowerCase() === s;
})); // &#39;pear&#39;, 因为pear全部是小写

console.log(arr.find(function (s) {
    return s.toUpperCase() === s;
})); // undefined, 因为没有全部是大写的元素</code></pre><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h4><p><code>findIndex()</code>和<code>find()</code>类似，也是查找符合条件的第一个元素，不同之处在于<code>findIndex()</code>会返回这个元素的索引，如果没有找到，返回<code>-1</code>：</p>
<pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];
console.log(arr.findIndex(function (s) {
    return s.toLowerCase() === s;
})); // 1, 因为&#39;pear&#39;的索引是1

console.log(arr.findIndex(function (s) {
    return s.toUpperCase() === s;
})); // -1</code></pre><h4 id="orEach"><a href="#orEach" class="headerlink" title="orEach"></a>orEach</h4><p><code>forEach()</code>和<code>map()</code>类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。<code>forEach()</code>常用于遍历数组，因此，传入的函数不需要返回值：</p>
<pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];
arr.forEach(console.log); // 依次打印每个元素</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code>function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}</code></pre><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code>var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</code></pre><p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code>f(); // 15</code></pre><p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<pre><code>var f1 = lazy_sum([1, 2, 3, 4, 5]);
var f2 = lazy_sum([1, 2, 3, 4, 5]);
f1 === f2; // false</code></pre><p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。我们来看一个例子：</p>
<pre><code>function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];</code></pre><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个<code>Array</code>中返回了。</p>
<p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p>
<pre><code>f1(); // 16
f2(); // 16
f3(); // 16</code></pre><p>全部都是<code>16</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>4</code>，因此最终结果为<code>16</code>。</p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code>function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];

f1(); // 1
f2(); // 4
f3(); // 9</code></pre><p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：</p>
<pre><code>(function (x) {
    return x * x;
})(3); // 9</code></pre><p>在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
<pre><code>&#39;use strict&#39;;

function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}</code></pre><p>它用起来像这样：</p>
<pre><code>var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13</code></pre><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量<code>x</code>，并且，从外部代码根本无法访问到变量<code>x</code>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数<code>pow2</code>和<code>pow3</code>：</p>
<pre><code>&#39;use strict&#39;;

function make_pow(n) { 
    return function (x) {
        return Math.pow(x, n);
    } 
} 
// 创建两个新函数:
var pow2 = make_pow(2);
var pow3 = make_pow(3);

console.log(pow2(5)); // 25
console.log(pow3(7)); // 343</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>为什么叫Arrow Function？因为它的定义用的就是一个箭头：</p>
<pre><code>x =&gt; x * x</code></pre><p>上面的箭头函数相当于：</p>
<pre><code>function (x) {
    return x * x;
}</code></pre><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：</p>
<pre><code>x =&gt; {
    if (x &gt; 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}</code></pre><p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p>
<pre><code>// 两个参数:
(x, y) =&gt; x * x + y * y

// 无参数:
() =&gt; 3.14

// 可变参数:
(x, y, ...rest) =&gt; {
    var i, sum = x + y;
    for (i=0; i&lt;rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}</code></pre><p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<pre><code>// SyntaxError:
x =&gt; { foo: x }</code></pre><p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p>
<pre><code>// ok:
x =&gt; ({ foo: x })</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</p>
<p>回顾前面的例子，由于JavaScript函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};</code></pre><p>现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25</code></pre><p>如果使用箭头函数，以前的那种hack写法：</p>
<pre><code>var that = this;</code></pre><p>就不再需要了。</p>
<p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) =&gt; y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25</code></pre><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>要编写一个产生斐波那契数列的函数，可以这么写：</p>
<pre><code>function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length &lt; max) {
        [a, b] = [b, a + b];
        arr.push(b);
    }
    return arr;
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre><p>函数只能返回一次，所以必须返回一个<code>Array</code>。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：</p>
<pre><code>function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n &lt; max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}</code></pre><p>直接调用试试：</p>
<pre><code>fib(5); // fib {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window}</code></pre><p>直接调用一个generator和调用函数不一样，<code>fib(5)</code>仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：</p>
<pre><code>var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}</code></pre><p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>
<p>当执行到<code>done</code>为<code>true</code>时，这个generator对象就已经全部执行完毕，不要再继续调用<code>next()</code>了。</p>
<p>generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。</p>
<p>没有generator之前的黑暗时代，用AJAX时需要这么写代码：</p>
<pre><code>ajax(&#39;http://url-1&#39;, data1, function (err, result) {
    if (err) {
        return handle(err);
    }
    ajax(&#39;http://url-2&#39;, data2, function (err, result) {
        if (err) {
            return handle(err);
        }
        ajax(&#39;http://url-3&#39;, data3, function (err, result) {
            if (err) {
                return handle(err);
            }
            return success(result);
        });
    });
});</code></pre><p>回调越多，代码越难看。</p>
<p>有了generator的美好时代，用AJAX时可以这么写：</p>
<pre><code>try {
    r1 = yield ajax(&#39;http://url-1&#39;, data1);
    r2 = yield ajax(&#39;http://url-2&#39;, data2);
    r3 = yield ajax(&#39;http://url-3&#39;, data3);
    success(r3);
}
catch (err) {
    handle(err);
}</code></pre><p>看上去是同步的代码，实际执行是异步的。</p>
<h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><h4 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h4><p>除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚<code>int</code>和<code>Integer</code>这种暧昧关系。</p>
<p><code>number</code>、<code>boolean</code>和<code>string</code>都有包装对象。没错，在JavaScript中，字符串也区分<code>string</code>类型和它的包装类型。包装对象用<code>new</code>创建：</p>
<pre><code>var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String(&#39;str&#39;); // &#39;str&#39;,生成了新的包装类型</code></pre><p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为<code>object</code>了！所以，包装对象和原始值用<code>===</code>比较会返回<code>false</code>：</p>
<pre><code>typeof new Number(123); // &#39;object&#39;
new Number(123) === 123; // false

typeof new Boolean(true); // &#39;object&#39;
new Boolean(true) === true; // false

typeof new String(&#39;str&#39;); // &#39;object&#39;
new String(&#39;str&#39;) === &#39;str&#39;; // false</code></pre><p>所以<em>闲的蛋疼也不要使用包装对象</em>！尤其是针对<code>string</code>类型！！！</p>
<p>如果我们在使用<code>Number</code>、<code>Boolean</code>和<code>String</code>时，没有写<code>new</code>会发生什么情况？</p>
<p>此时，<code>Number()</code>、<code>Boolean</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）：</p>
<pre><code>var n = Number(&#39;123&#39;); // 123，相当于parseInt()或parseFloat()
typeof n; // &#39;number&#39;

var b = Boolean(&#39;true&#39;); // true
typeof b; // &#39;boolean&#39;

var b2 = Boolean(&#39;false&#39;); // true! &#39;false&#39;字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(&#39;&#39;); // false

var s = String(123.45); // &#39;123.45&#39;
typeof s; // &#39;string&#39;</code></pre><p>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>
<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>
<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li>
</ul>
<p>最后有细心的同学指出，任何对象都有<code>toString()</code>方法吗？<code>null</code>和<code>undefined</code>就没有！确实如此，这两个特殊值要除外，虽然<code>null</code>还伪装成了<code>object</code>类型。</p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>
<p>要获取系统当前时间，用：</p>
<pre><code>var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳</code></pre><p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p>
<p>如果要创建一个指定日期和时间的<code>Date</code>对象，可以用：</p>
<pre><code>var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</code></pre><p>你可能观察到了一个<em>非常非常坑爹</em>的地方，就是JavaScript的月份范围用整数表示是0~11，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示6月，我们传入的是<code>5</code>！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。</p>
<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>avaScript有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。</p>
<p>两种写法是一样的：</p>
<pre><code>var re1 = /ABC\-001/;
var re2 = new RegExp(&#39;ABC\\-001&#39;);

re1; // /ABC\-001/
re2; // /ABC\-001/</code></pre><p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个<code>\\</code>实际上是一个<code>\</code>。</p>
<p>先看看如何判断正则表达式是否匹配：</p>
<pre><code>var re = /^\d{3}\-\d{3,8}$/;
re.test(&#39;010-12345&#39;); // true
re.test(&#39;010-1234x&#39;); // false
re.test(&#39;010 12345&#39;); // false</code></pre><p>RegExp对象的<code>test()</code>方法用于测试给定的字符串是否符合条件。</p>
<h4 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h4><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<pre><code>&#39;a b   c&#39;.split(&#39; &#39;); // [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</code></pre><p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<pre><code>&#39;a b   c&#39;.split(/\s+/); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p>
<pre><code>&#39;a,b, c  d&#39;.split(/[\s\,]+/); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre><p>再加入<code>;</code>试试：</p>
<pre><code>&#39;a,b;; c  d&#39;.split(/[\s\,\;]+/); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre><p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<pre><code>var re = /^(\d{3})-(\d{3,8})$/;
re.exec(&#39;010-12345&#39;); // [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]
re.exec(&#39;010 12345&#39;); // null</code></pre><p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>让我们先把小明这个对象序列化成JSON格式的字符串：</p>
<pre><code>&#39;use strict&#39;;

var xiaoming = {
    name: &#39;小明&#39;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,
    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;]
};
var s = JSON.stringify(xiaoming);
console.log(s);
</code></pre><p>要输出得好看一些，可以加上参数，按缩进输出：</p>
<pre><code>JSON.stringify(xiaoming, null, &#39;  &#39;);</code></pre><p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：</p>
<pre><code>JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;  &#39;);</code></pre><p>结果：</p>
<pre><code>{
  &quot;name&quot;: &quot;小明&quot;,
  &quot;skills&quot;: [
    &quot;JavaScript&quot;,
    &quot;Java&quot;,
    &quot;Python&quot;,
    &quot;Lisp&quot;
  ]
}</code></pre><p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
<pre><code>function convert(key, value) {
    if (typeof value === &#39;string&#39;) {
        return value.toUpperCase();
    }
    return value;
}

JSON.stringify(xiaoming, convert, &#39;  &#39;);</code></pre><p>上面的代码把所有属性值都变成大写：</p>
<pre><code>{
  &quot;name&quot;: &quot;小明&quot;,
  &quot;age&quot;: 14,
  &quot;gender&quot;: true,
  &quot;height&quot;: 1.65,
  &quot;grade&quot;: null,
  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; MIDDLE SCHOOL&quot;,
  &quot;skills&quot;: [
    &quot;JAVASCRIPT&quot;,
    &quot;JAVA&quot;,
    &quot;PYTHON&quot;,
    &quot;LISP&quot;
  ]
}</code></pre><p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</p>
<pre><code>var xiaoming = {
    name: &#39;小明&#39;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,
    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            &#39;Name&#39;: this.name,
            &#39;Age&#39;: this.age
        };
    }
};

JSON.stringify(xiaoming); // &#39;{&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14}&#39;</code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p>
<pre><code>JSON.parse(&#39;[1,2,3,true]&#39;); // [1, 2, 3, true]
JSON.parse(&#39;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&#39;); // Object {name: &#39;小明&#39;, age: 14}
JSON.parse(&#39;true&#39;); // true
JSON.parse(&#39;123.45&#39;); // 123.45</code></pre><p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</p>
<pre><code>var obj = JSON.parse(&#39;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&#39;, function (key, value) {
    if (key === &#39;name&#39;) {
        return value + &#39;同学&#39;;
    }
    return value;
});
console.log(JSON.stringify(obj)); // {name: &#39;小明同学&#39;, age: 14}
</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>avaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<p>如果你把<code>xiaoming</code>的原型指向其他对象：</p>
<pre><code>var Bird = {
    fly: function () {
        console.log(this.name + &#39; is flying...&#39;);
    }
};

xiaoming.__proto__ = Bird;</code></pre><p>现在<code>xiaoming</code>已经无法<code>run()</code>了，他已经变成了一只鸟：</p>
<pre><code>xiaoming.fly(); // 小明 is flying...</code></pre><p><em>请注意</em>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。<code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建<code>xiaoming</code>：</p>
<pre><code>// 原型对象:
var Student = {
    name: &#39;Robot&#39;,
    height: 1.2,
    run: function () {
        console.log(this.name + &#39; is running...&#39;);
    }
};

function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent(&#39;小明&#39;);
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</p>
<p>当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>
<p>函数也是一个对象，它的原型链是：</p>
<pre><code>foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</code></pre><p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>
<p>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<pre><code>function Student(name) {
    this.name = name;
    this.hello = function () {
        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
    }
}</code></pre><p>你会问，咦，这不是一个普通函数吗？</p>
<p>这确实是一个普通函数，但是在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：</p>
<pre><code>var xiaoming = new Student(&#39;小明&#39;);
xiaoming.name; // &#39;小明&#39;
xiaoming.hello(); // Hello, 小明!</code></pre><p><em>注意</em>，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>
<h4 id="忘记写new怎么办"><a href="#忘记写new怎么办" class="headerlink" title="忘记写new怎么办"></a>忘记写new怎么办</h4><p>如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写<code>new</code>怎么办？</p>
<p>在strict模式下，<code>this.name = name</code>将报错，因为<code>this</code>绑定为<code>undefined</code>，在非strict模式下，<code>this.name = name</code>不报错，因为<code>this</code>绑定为<code>window</code>，于是无意间创建了全局变量<code>name</code>，并且返回<code>undefined</code>，这个结果更糟糕。</p>
<p>所以，调用构造函数千万不要忘记写<code>new</code>。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如<a href="http://www.jslint.com/" target="_blank" rel="noopener">jslint</a>将可以帮你检测到漏写的<code>new</code>。</p>
<p>最后，我们还可以编写一个<code>createStudent()</code>函数，在内部封装所有的<code>new</code>操作。一个常用的编程模式像这样：</p>
<pre><code>function Student(props) {
    this.name = props.name || &#39;匿名&#39;; // 默认值为&#39;匿名&#39;
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
};

function createStudent(props) {
    return new Student(props || {})
}</code></pre><p>这个<code>createStudent()</code>函数有几个巨大的优点：一是不需要<code>new</code>来调用，二是参数非常灵活，可以不传，也可以这么传：</p>
<pre><code>var xiaoming = createStudent({
    name: &#39;小明&#39;
});

xiaoming.grade; // 1</code></pre><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。</p>
<p>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。</p>
<p>但是办法还是有的。我们先回顾<code>Student</code>构造函数：</p>
<pre><code>function Student(props) {
    this.name = props.name || &#39;Unnamed&#39;;
}

Student.prototype.hello = function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
}</code></pre><p>以及<code>Student</code>的原型链：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.liaoxuefeng.com/files/attachments/1034288810160288/l" alt="js-proto"></p>
<p>现在，我们要基于<code>Student</code>扩展出<code>PrimaryStudent</code>，可以先定义出<code>PrimaryStudent</code>：</p>
<pre><code>function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}</code></pre><p>但是，调用了<code>Student</code>构造函数不等于继承了<code>Student</code>，<code>PrimaryStudent</code>创建的对象的原型是：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null</code></pre><p>必须想办法把原型链修改为：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</code></pre><p>这样，原型链对了，继承关系就对了。新的基于<code>PrimaryStudent</code>创建的对象不但能调用<code>PrimaryStudent.prototype</code>定义的方法，也可以调用<code>Student.prototype</code>定义的方法。</p>
<p>如果你想用最简单粗暴的方法这么干：</p>
<pre><code>PrimaryStudent.prototype = Student.prototype;</code></pre><p>是不行的！如果这样的话，<code>PrimaryStudent</code>和<code>Student</code>共享一个原型对象，那还要定义<code>PrimaryStudent</code>干啥？</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向<code>Student.prototype</code>。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数<code>F</code>来实现：</p>
<pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: &#39;小明&#39;,
    grade: 2
});
xiaoming.name; // &#39;小明&#39;
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true</code></pre><p>用一张图来表示新的原型链：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.liaoxuefeng.com/files/attachments/1034288859918112/l" alt="js-proto-extend"></p>
<p>注意，函数<code>F</code>仅用于桥接，我们仅创建了一个<code>new F()</code>实例，而且，没有改变原有的<code>Student</code>定义的原型链。</p>
<p>如果把继承这个动作用一个<code>inherits()</code>函数封装起来，还可以隐藏<code>F</code>的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}</code></pre><p>这个<code>inherits()</code>函数可以复用：</p>
<pre><code>function Student(props) {
    this.name = props.name || &#39;Unnamed&#39;;
}

Student.prototype.hello = function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</li>
<li>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ol>
<h3 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h3><p>在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p>
<p>有没有更简单的写法？有！</p>
<p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>
<p>我们先回顾用函数实现<code>Student</code>的方法：</p>
<pre><code>function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);</code></pre><p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：</p>
<pre><code>class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
    }
}</code></pre><p>比较一下就可以发现，<code>class</code>的定义包含了构造函数<code>constructor</code>和定义在原型对象上的函数<code>hello()</code>（注意没有<code>function</code>关键字），这样就避免了<code>Student.prototype.hello = function () {...}</code>这样分散的代码。</p>
<p>最后，创建一个<code>Student</code>对象代码和前面章节完全一样：</p>
<pre><code>var xiaoming = new Student(&#39;小明&#39;);
xiaoming.hello();</code></pre><h3 id="lass继承"><a href="#lass继承" class="headerlink" title="lass继承"></a>lass继承</h3><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了。想一想我们从<code>Student</code>派生一个<code>PrimaryStudent</code>需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过<code>extends</code>来实现：</p>
<pre><code>class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert(&#39;I am at grade &#39; + this.grade);
    }
}</code></pre><p>注意<code>PrimaryStudent</code>的定义也是class关键字实现的，而<code>extends</code>则表示原型链对象来自<code>Student</code>。子类的构造函数可能会与父类不太相同，例如，<code>PrimaryStudent</code>需要<code>name</code>和<code>grade</code>两个参数，并且需要通过<code>super(name)</code>来调用父类的构造函数，否则父类的<code>name</code>属性无法正常初始化。</p>
<p><code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello</code>方法，我们又在子类中定义了新的<code>myGrade</code>方法。</p>
<p>ES6引入的<code>class</code>和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，<code>class</code>的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用<code>class</code>的好处就是极大地简化了原型链代码。</p>
<p>你一定会问，<code>class</code>这么好用，能不能现在就用上？</p>
<p>现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把<code>class</code>代码转换为传统的<code>prototype</code>代码，可以试试<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>这个工具。</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。</p>
<p>目前主流的浏览器分这么几种：</p>
<ul>
<li>IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；</li>
<li>Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；</li>
<li>Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6；</li>
<li>Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；</li>
<li>移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。</li>
</ul>
<p>其他浏览器如Opera等由于市场份额太小就被自动忽略了。</p>
<p>另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。</p>
<p>不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。</p>
<p>在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。</p>
<h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p><code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p>
<p>兼容性：IE&lt;=8不支持。</p>
<p>对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p>
<h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括：</p>
<ul>
<li>navigator.appName：浏览器名称；</li>
<li>navigator.appVersion：浏览器版本；</li>
<li>navigator.language：浏览器设置的语言；</li>
<li>navigator.platform：操作系统类型；</li>
<li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li>
</ul>
<p><em>请注意</em>，<code>navigator</code>的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用<code>if</code>判断浏览器版本，例如：</p>
<pre><code>var width;
if (getIEVersion(navigator.userAgent) &lt; 9) {
    width = document.body.clientWidth;
} else {
    width = window.innerWidth;
}</code></pre><p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回<code>undefined</code>的特性，直接用短路运算符<code>||</code>计算：</p>
<pre><code>var width = window.innerWidth || document.body.clientWidth;</code></pre><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><p><code>screen</code>对象表示屏幕的信息，常用的属性有：</p>
<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p><code>location</code>对象表示当前页面的URL信息。例如，一个完整的URL：</p>
<pre><code>http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</code></pre><p>可以用<code>location.href</code>获取。要获得URL各个部分的值，可以这么写：</p>
<pre><code>location.protocol; // &#39;http&#39;
location.host; // &#39;www.example.com&#39;
location.port; // &#39;8080&#39;
location.pathname; // &#39;/path/index.html&#39;
location.search; // &#39;?a=1&amp;b=2&#39;
location.hash; // &#39;TOP&#39;</code></pre><p>要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用<code>location.reload()</code>方法非常方便。</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p>
<p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的，但是可以动态改变：</p>
<p>请观察浏览器窗口标题的变化。</p>
<p>要查找DOM树的某个节点，需要从<code>document</code>对象开始查找。最常用的查找是根据ID和Tag Name。</p>
<p>用<code>document</code>对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：</p>
<pre><code>var menu = document.getElementById(&#39;drink-menu&#39;);
var drinks = document.getElementsByTagName(&#39;dt&#39;);
var i, s;

s = &#39;提供的饮料有:&#39;;
for (i=0; i&lt;drinks.length; i++) {
    s = s + drinks[i].innerHTML + &#39;,&#39;;
}
console.log(s);</code></pre><p><code>document</code>对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。</p>
<p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p>
<p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p>
<p>JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p>
<pre><code>document.cookie; // &#39;v=123; remember=true; prefer=zh&#39;</code></pre><p>为了解决这个问题，服务器在设置Cookie时可以使用<code>httpOnly</code>，设定了<code>httpOnly</code>的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持<code>httpOnly</code>选项，IE从IE6 SP1开始支持。</p>
<p>为了确保安全，服务器端在设置Cookie时，应该始终坚持使用<code>httpOnly</code>。</p>
<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用<code>history.back()</code>可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用<code>history.back()</code>，试图回到登录前的页面。这是一种错误的方法。</p>
<p>任何情况，你都不应该使用<code>history</code>这个对象了。</p>
<h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ul>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ul>
<p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是<code>document.getElementById()</code>和<code>document.getElementsByTagName()</code>，以及CSS选择器<code>document.getElementsByClassName()</code>。</p>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：</p>
<pre><code>// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector(&#39;#q1&#39;);

// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll(&#39;div.highlighted &gt; p&#39;);</code></pre><h4 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h4><p>拿到一个DOM节点后，我们可以对它进行更新。</p>
<p>可以直接修改节点的文本，方法有两种：</p>
<p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p>
<pre><code>// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&#39;p-id&#39;);
// 设置文本为abc:
p.innerHTML = &#39;ABC&#39;; // &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;
// 设置HTML:
p.innerHTML = &#39;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#39;;
// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</code></pre><p>用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。</p>
<p>第二种是修改<code>innerText</code>或<code>textContent</code>属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：</p>
<pre><code>// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&#39;p-id&#39;);
// 设置文本:
p.innerText = &#39;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#39;;
// HTML被自动编码，无法设置一个&lt;script&gt;节点:
// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</code></pre><p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意IE&lt;9不支持<code>textContent</code>。</p>
<p>修改CSS也是经常需要的操作。DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置。因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名<code>fontSize</code>：</p>
<pre><code>// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&#39;p-id&#39;);
// 设置CSS:
p.style.color = &#39;#ff0000&#39;;
p.style.fontSize = &#39;20px&#39;;
p.style.paddingTop = &#39;2em&#39;;</code></pre><h4 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h4><p>我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？</p>
<p>如果这个DOM节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p>
<p>如果这个DOM节点不是空的，那就不能这么做，因为<code>innerHTML</code>会直接替换掉原来的所有子节点。</p>
<p>有两个办法可以插入新的节点。一个是使用<code>appendChild</code>，把一个子节点添加到父节点的最后一个子节点。例如：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;</code></pre><p>把<code>&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;</code>添加到<code>&lt;div id=&quot;list&quot;&gt;</code>的最后一项：</p>
<pre><code>var
    js = document.getElementById(&#39;js&#39;),
    list = document.getElementById(&#39;list&#39;);
list.appendChild(js);</code></pre><p>现在，HTML结构变成了这样：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;
&lt;/div&gt;</code></pre><p>因为我们插入的<code>js</code>节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。</p>
<p>更多的时候我们会从零创建一个新的节点，然后插入到指定位置：</p>
<pre><code>var
    list = document.getElementById(&#39;list&#39;),
    haskell = document.createElement(&#39;p&#39;);
haskell.id = &#39;haskell&#39;;
haskell.innerText = &#39;Haskell&#39;;
list.appendChild(haskell);</code></pre><p>这样我们就动态添加了一个新的节点：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
    &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt;
&lt;/div&gt;</code></pre><h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h4><p>如果我们要把子节点插入到指定的位置怎么办？可以使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到<code>referenceElement</code>之前。</p>
<p>还是以上面的HTML为例，假定我们要把<code>Haskell</code>插入到<code>Python</code>之前：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;</code></pre><p>可以这么写：</p>
<pre><code>var
    list = document.getElementById(&#39;list&#39;),
    ref = document.getElementById(&#39;python&#39;),
    haskell = document.createElement(&#39;p&#39;);
haskell.id = &#39;haskell&#39;;
haskell.innerText = &#39;Haskell&#39;;
list.insertBefore(haskell, ref);</code></pre><p>新的HTML结构如下：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;</code></pre><p>可见，使用<code>insertBefore</code>重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代<code>children</code>属性实现：</p>
<pre><code>var
    i, c,
    list = document.getElementById(&#39;list&#39;);
for (i = 0; i &lt; list.children.length; i++) {
    c = list.children[i]; // 拿到第i个子节点
}</code></pre><h4 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h4><p>删除一个DOM节点就比插入要容易得多。</p>
<p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉：</p>
<pre><code>// 拿到待删除节点:
var self = document.getElementById(&#39;to-be-removed&#39;);
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true</code></pre><p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
<p>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新。</p>
<p>例如，对于如下HTML结构：</p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
    &lt;p&gt;First&lt;/p&gt;
    &lt;p&gt;Second&lt;/p&gt;
&lt;/div&gt;</code></pre><p>当我们用如下代码删除子节点时：</p>
<pre><code>var parent = document.getElementById(&#39;parent&#39;);
parent.removeChild(parent.children[0]);
parent.removeChild(parent.children[1]); // &lt;-- 浏览器报错</code></pre><p>浏览器报错：<code>parent.children[1]</code>不是一个有效的节点。原因就在于，当<code>&lt;p&gt;First&lt;/p&gt;</code>节点被删除后，<code>parent.children</code>的节点数量已经从2变为了1，索引<code>[1]</code>已经不存在了。</p>
<p>因此，删除多个节点时，要注意<code>children</code>属性时刻都在变化。</p>
<h3 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h3><p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p>
<p>不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML表单的输入控件主要有以下几种：</p>
<ul>
<li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li>
<li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li>
<li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li>
<li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li>
<li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li>
<li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li>
</ul>
<h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用<code>value</code>获得对应的用户输入值：</p>
<pre><code>// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;
var input = document.getElementById(&#39;email&#39;);
input.value; // &#39;用户输入的值&#39;</code></pre><p>这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用<code>checked</code>判断：</p>
<pre><code>// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;
// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;
var mon = document.getElementById(&#39;monday&#39;);
var tue = document.getElementById(&#39;tuesday&#39;);
mon.value; // &#39;1&#39;
tue.value; // &#39;2&#39;
mon.checked; // true或者false
tue.checked; // true或者false</code></pre><h4 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h4><p>设置值和获取值类似，对于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以：</p>
<pre><code>// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;
var input = document.getElementById(&#39;email&#39;);
input.value = &#39;test@example.com&#39;; // 文本框的内容已更新</code></pre><p>对于单选框和复选框，设置<code>checked</code>为<code>true</code>或<code>false</code>即可。</p>
<h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><p>最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。</p>
<p>方式一是通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的<code>click</code>事件，在JavaScript代码中提交表单：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id=&quot;test-form&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;doSubmitForm()&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function doSubmitForm() {
    var form = document.getElementById(&#39;test-form&#39;);
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
&lt;/script&gt;</code></pre><p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id=&quot;test-form&quot; onsubmit=&quot;return checkForm()&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var form = document.getElementById(&#39;test-form&#39;);
    // 可以在此修改form的input...
    // 继续下一步:
    return true;
}
&lt;/script&gt;</code></pre><p>注意要<code>return true</code>来告诉浏览器继续提交，如果<code>return false</code>，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p>
<p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。</p>
<p>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改<code>&lt;input&gt;</code>：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;
    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var pwd = document.getElementById(&#39;password&#39;);
    // 把用户输入的明文变为MD5:
    pwd.value = toMD5(pwd.value);
    // 继续下一步:
    return true;
}
&lt;/script&gt;</code></pre><p>这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<code>*</code>变成32个<code>*</code>（因为MD5有32个字符）。</p>
<p>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;
    &lt;input type=&quot;password&quot; id=&quot;input-password&quot;&gt;
    &lt;input type=&quot;hidden&quot; id=&quot;md5-password&quot; name=&quot;password&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var input_pwd = document.getElementById(&#39;input-password&#39;);
    var md5_pwd = document.getElementById(&#39;md5-password&#39;);
    // 把用户输入的明文变为MD5:
    md5_pwd.value = toMD5(input_pwd.value);
    // 继续下一步:
    return true;
}
&lt;/script&gt;</code></pre><p>注意到<code>id</code>为<code>md5-password</code>的<code>&lt;input&gt;</code>标记了<code>name=&quot;password&quot;</code>，而用户输入的<code>id</code>为<code>input-password</code>的<code>&lt;input&gt;</code>没有<code>name</code>属性。没有<code>name</code>属性的<code>&lt;input&gt;</code>的数据不会被提交。</p>
<h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p>
<p><em>注意</em>：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。</p>
<h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。</p>
<p>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。</p>
<p>HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。</p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</p>
<p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p>
<p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p>
<p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p>
<p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p>
<p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>了解CORS前，我们先搞明白概念：</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>用一个图来表示就是：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.liaoxuefeng.com/files/attachments/1027024093709472/l" alt="js-cors"></p>
<p>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>
<p>上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，<code>X-Custom: 12345</code>），通常能满足90%的需求。</p>
<p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>
<pre><code>/* CSS */
@font-face {
  font-family: &#39;FontAwesome&#39;;
  src: url(&#39;http://cdn.com/fonts/fontawesome.ttf&#39;) format(&#39;truetype&#39;);
}</code></pre><p>如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>
<p>对于PUT、DELETE以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个<code>OPTIONS</code>请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>
<pre><code>OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST</code></pre><p>服务器必须响应并明确指出允许的Method：</p>
<pre><code>HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400</code></pre><p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>
<p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理<code>POST</code>和<code>PUT</code>请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p>
<p>需要深入了解CORS的童鞋请移步<a href="http://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C文档</a>。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在JavaScript的世界中，所有代码都是单线程执行的。</p>
<p>由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：</p>
<pre><code>function callback() {
    console.log(&#39;Done&#39;);
}
console.log(&#39;before setTimeout()&#39;);
setTimeout(callback, 1000); // 1秒钟后调用callback函数
console.log(&#39;after setTimeout()&#39;);</code></pre><p>观察上述代码执行，在Chrome的控制台输出可以看到：</p>
<pre><code>before setTimeout()
after setTimeout()
(等待1秒后)
Done</code></pre><p>可见，异步操作会在将来的某个时间点触发一个函数调用。</p>
<p>AJAX就是典型的异步操作。以上一节的代码为例：</p>
<pre><code>request.onreadystatechange = function () {
    if (request.readyState === 4) {
        if (request.status === 200) {
            return success(request.responseText);
        } else {
            return fail(request.status);
        }
    }
}</code></pre><p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p>
<p>有没有更好的写法？比如写成这样：</p>
<pre><code>var ajax = ajaxGet(&#39;http://...&#39;);
ajax.ifSuccess(success)
    .ifFail(fail);</code></pre><p>这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用<code>success</code>函数或<code>fail</code>函数。</p>
<p>古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。</p>
<pre><code>我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：

function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    log(&#39;set timeout to: &#39; + timeOut + &#39; seconds.&#39;);
    setTimeout(function () {
        if (timeOut &lt; 1) {
            log(&#39;call resolve()...&#39;);
            resolve(&#39;200 OK&#39;);
        }
        else {
            log(&#39;call reject()...&#39;);
            reject(&#39;timeout in &#39; + timeOut + &#39; seconds.&#39;);
        }
    }, timeOut * 1000);
}
这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve(&#39;200 OK&#39;)，如果执行失败，我们将调用reject(&#39;timeout in &#39; + timeOut + &#39; seconds.&#39;)。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。

有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：

var p1 = new Promise(test);
var p2 = p1.then(function (result) {
    console.log(&#39;成功：&#39; + result);
});
var p3 = p2.catch(function (reason) {
    console.log(&#39;失败：&#39; + reason);
});
变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：

// 如果成功，执行这个函数：
p1.then(function (result) {
    console.log(&#39;成功：&#39; + result);
});
当test函数执行失败时，我们告诉Promise对象：

p2.catch(function (reason) {
    console.log(&#39;失败：&#39; + reason);
});
Promise对象可以串联起来，所以上述代码可以简化为：

new Promise(test).then(function (result) {
    console.log(&#39;成功：&#39; + result);
}).catch(function (reason) {
    console.log(&#39;失败：&#39; + reason);
});</code></pre><p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.liaoxuefeng.com/files/attachments/1027242914217888/l" alt="promise"></p>
<p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p>
<p>要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：</p>
<pre><code>job1.then(job2).then(job3).catch(handleError);</code></pre><p>其中，<code>job1</code>、<code>job2</code>和<code>job3</code>都是Promise对象。</p>
<p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>
<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用<code>Promise.all()</code>实现如下：</p>
<pre><code>var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, &#39;P1&#39;);
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, &#39;P2&#39;);
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: [&#39;P1&#39;, &#39;P2&#39;]
});</code></pre><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p>
<pre><code>var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, &#39;P1&#39;);
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, &#39;P2&#39;);
});
Promise.race([p1, p2]).then(function (result) {
    console.log(result); // &#39;P1&#39;
});</code></pre><p>由于<code>p1</code>执行较快，Promise的<code>then()</code>将获得结果<code>&#39;P1&#39;</code>。<code>p2</code>仍在继续执行，但执行结果将被丢弃。</p>
<p>如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。</p>
<p>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p>
<p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p>
<pre><code>&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</code></pre><p>由于浏览器对HTML5标准支持不一致，所以，通常在<code>&lt;canvas&gt;</code>内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略<code>&lt;canvas&gt;</code>内部的HTML，如果浏览器不支持Canvas，它将显示<code>&lt;canvas&gt;</code>内部的HTML：</p>
<pre><code>&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
    &lt;p&gt;Current Price: 25.51&lt;/p&gt;
&lt;/canvas&gt;</code></pre><p>在使用Canvas前，用<code>canvas.getContext</code>来测试浏览器是否支持Canvas：</p>
<pre><code>&lt;!-- HTML代码 --&gt;
&lt;canvas id=&quot;test-canvas&quot; width=&quot;200&quot; heigth=&quot;100&quot;&gt;
    &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;
&lt;/canvas&gt;</code></pre><p><code>getContext(&#39;2d&#39;)</code>方法让我们拿到一个<code>CanvasRenderingContext2D</code>对象，所有的绘图操作都需要通过这个对象完成。</p>
<pre><code>var ctx = canvas.getContext(&#39;2d&#39;);</code></pre><p>如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：</p>
<pre><code>gl = canvas.getContext(&quot;webgl&quot;);</code></pre><p>本节我们只专注于绘制2D图形。</p>
<h3 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h3><p>我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.liaoxuefeng.com/files/attachments/1028111602807456/l" alt="canvas-xy"></p>
<p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code>对象有若干方法来绘制图形：</p>
<pre><code>&#39;use strict&#39;; 
var canvas = document.getElementById(&#39;test-shape-canvas&#39;),    
ctx = canvas.getContext(&#39;2d&#39;); </code></pre><pre><code>ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = &#39;#dddddd&#39;; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = &#39;#0000ff&#39;;
ctx.stroke(path);</code></pre><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p>
<pre><code>&#39;use strict&#39;;
var     canvas = document.getElementById(&#39;test-text-canvas&#39;), 
ctx = canvas.getContext(&#39;2d&#39;);</code></pre><pre><code>ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = &#39;#666666&#39;;
ctx.font = &#39;24px Arial&#39;;
ctx.fillStyle = &#39;#333333&#39;;
ctx.fillText(&#39;带阴影的文字&#39;, 20, 40);
</code></pre><p>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</p>
<ul>
<li>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</li>
<li>尽量使用整数坐标而不是浮点数；</li>
<li>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</li>
<li>背景图片如果不变可以直接用<code>&lt;img&gt;</code>标签并放到最底层。</li>
</ul>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。</p>
<p>江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。</p>
<p>jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情：</p>
<ul>
<li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li>
<li>简洁的操作DOM的方法：写<code>$(&#39;#test&#39;)</code>肯定比<code>document.getElementById(&#39;test&#39;)</code>来得简洁；</li>
<li>轻松实现动画、修改CSS等各种操作。</li>
</ul>
<p>jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！</p>
<h4 id="使用jQuery"><a href="#使用jQuery" class="headerlink" title="使用jQuery"></a>使用jQuery</h4><p>使用jQuery只需要在页面的<code>&lt;head&gt;</code>引入jQuery文件即可：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;
    ...
&lt;/head&gt;
&lt;body&gt;
    ...
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h4><p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量<code>jQuery</code>中，而<code>$</code>也是一个合法的变量名，它是变量<code>jQuery</code>的别名：</p>
<pre><code>window.jQuery; // jQuery(selector, context)
window.$; // jQuery(selector, context)
$ === jQuery; // true
typeof($); // &#39;function&#39;</code></pre><p><code>$</code>本质上就是一个函数，但是函数也是对象，于是<code>$</code>除了可以直接调用外，也可以有很多其他属性。</p>
<p><em>注意</em>，你看到的<code>$</code>函数名可能不是<code>jQuery(selector, context)</code>，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码<code>$</code>函数可能变成<code>a(b, c)</code>。</p>
<p>绝大多数时候，我们都直接用<code>$</code>（因为写起来更简单嘛）。但是，如果<code>$</code>这个变量不幸地被占用了，而且还不能改，那我们就只能让<code>jQuery</code>把<code>$</code>变量交出来，然后就只能使用<code>jQuery</code>这个变量：</p>
<pre><code>$; // jQuery(selector, context)
jQuery.noConflict();
$; // undefined
jQuery; // jQuery(selector, context)</code></pre><p>这种黑魔法的原理是jQuery在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用<code>jQuery.noConflict()</code>时会把原来保存的变量还原。</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h3 id="按ID查找"><a href="#按ID查找" class="headerlink" title="按ID查找"></a>按ID查找</h3><p>如果某个DOM节点有<code>id</code>属性，利用jQuery查找如下：</p>
<pre><code>// 查找&lt;div id=&quot;abc&quot;&gt;:
var div = $(&#39;#abc&#39;);</code></pre><p><em>注意</em>，<code>#abc</code>以<code>#</code>开头。返回的对象是jQuery对象。</p>
<p>什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p>
<p>以上面的查找为例，如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>存在，返回的jQuery对象如下：</p>
<pre><code>[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]</code></pre><p>如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>不存在，返回的jQuery对象如下：</p>
<pre><code>[]</code></pre><p>总之jQuery的选择器不会返回<code>undefined</code>或者<code>null</code>，这样的好处是你不必在下一行判断<code>if (div === undefined)</code>。</p>
<p>jQuery对象和DOM对象之间可以互相转化：</p>
<pre><code>var div = $(&#39;#abc&#39;); // jQuery对象
var divDom = div.get(0); // 假设存在div，获取第1个DOM元素
var another = $(divDom); // 重新把DOM包装为jQuery对象</code></pre><p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用<code>$(aDomObject)</code>把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p>
<h3 id="按tag查找"><a href="#按tag查找" class="headerlink" title="按tag查找"></a>按tag查找</h3><p>按tag查找只需要写上tag名称就可以了：</p>
<pre><code>var ps = $(&#39;p&#39;); // 返回所有&lt;p&gt;节点
ps.length; // 数一数页面有多少个&lt;p&gt;节点</code></pre><h3 id="按class查找"><a href="#按class查找" class="headerlink" title="按class查找"></a>按class查找</h3><p>按class查找注意在class名称前加一个<code>.</code>：</p>
<pre><code>var a = $(&#39;.red&#39;); // 所有节点包含`class=&quot;red&quot;`都将返回
// 例如:
// &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt;
// &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt;</code></pre><p>通常很多节点有多个class，我们可以查找同时包含<code>red</code>和<code>green</code>的节点：</p>
<pre><code>var a = $(&#39;.red.green&#39;); // 注意没有空格！
// 符合条件的节点：
// &lt;div class=&quot;red green&quot;&gt;...&lt;/div&gt;
// &lt;div class=&quot;blue green red&quot;&gt;...&lt;/div&gt;</code></pre><h4 id="按属性查找"><a href="#按属性查找" class="headerlink" title="按属性查找"></a>按属性查找</h4><p>一个DOM节点除了<code>id</code>和<code>class</code>外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找：</p>
<pre><code>var email = $(&#39;[name=email]&#39;); // 找出&lt;??? name=&quot;email&quot;&gt;
var passwordInput = $(&#39;[type=password]&#39;); // 找出&lt;??? type=&quot;password&quot;&gt;
var a = $(&#39;[items=&quot;A B&quot;]&#39;); // 找出&lt;??? items=&quot;A B&quot;&gt;</code></pre><p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>按属性查找还可以使用前缀查找或者后缀查找：</p>
<pre><code>var icons = $(&#39;[name^=icon]&#39;); // 找出所有name属性值以icon开头的DOM
// 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot;
var names = $(&#39;[name$=with]&#39;); // 找出所有name属性值以with结尾的DOM
// 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot;</code></pre><p>这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：</p>
<pre><code>var icons = $(&#39;[class^=&quot;icon-&quot;]&#39;); // 找出所有class包含至少一个以`icon-`开头的DOM
// 例如: class=&quot;icon-clock&quot;, class=&quot;abc icon-home&quot;</code></pre><h4 id="组合查找"><a href="#组合查找" class="headerlink" title="组合查找"></a>组合查找</h4><p>组合查找就是把上述简单选择器组合起来使用。如果我们查找<code>$(&#39;[name=email]&#39;)</code>，很可能把表单外的<code>&lt;div name=&quot;email&quot;&gt;</code>也找出来，但我们只希望查找<code>&lt;input&gt;</code>，就可以这么写：</p>
<pre><code>var emailInput = $(&#39;input[name=email]&#39;); // 不会找出&lt;div name=&quot;email&quot;&gt;</code></pre><p>同样的，根据tag和class来组合查找也很常见：</p>
<pre><code>var tr = $(&#39;tr.red&#39;); // 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;</code></pre><h4 id="多项选择器"><a href="#多项选择器" class="headerlink" title="多项选择器"></a>多项选择器</h4><p>多项选择器就是把多个选择器用<code>,</code>组合起来一块选：</p>
<pre><code>$(&#39;p,div&#39;); // 把&lt;p&gt;和&lt;div&gt;都选出来
$(&#39;p.red,p.green&#39;); // 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来</code></pre><p>要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class=&quot;red green&quot;&gt;</code>不会被上面的<code>$(&#39;p.red,p.green&#39;)</code>选择两次。</p>
<h4 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h4><p>除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大。</p>
<p>因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>
<h3 id="层级选择器（Descendant-Selector）"><a href="#层级选择器（Descendant-Selector）" class="headerlink" title="层级选择器（Descendant Selector）"></a>层级选择器（Descendant Selector）</h3><p>如果两个DOM元素具有层级关系，就可以用<code>$(&#39;ancestor descendant&#39;)</code>来选择，层级之间用空格隔开。例如：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div class=&quot;testing&quot;&gt;
    &lt;ul class=&quot;lang&quot;&gt;
        &lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;
        &lt;li class=&quot;lang-python&quot;&gt;Python&lt;/li&gt;
        &lt;li class=&quot;lang-lua&quot;&gt;Lua&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre><p>要选出JavaScript，可以用层级选择器：</p>
<pre><code>$(&#39;ul.lang li.lang-javascript&#39;); // [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]
$(&#39;div.testing li.lang-javascript&#39;); // [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</code></pre><p>因为<code>&lt;div&gt;</code>和<code>&lt;ul&gt;</code>都是<code>&lt;li&gt;</code>的祖先节点，所以上面两种方式都可以选出相应的<code>&lt;li&gt;</code>节点。</p>
<p>要选择所有的<code>&lt;li&gt;</code>节点，用：</p>
<pre><code>$(&#39;ul.lang li&#39;);</code></pre><p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素</p>
<p>例如：</p>
<pre><code>$(&#39;form[name=upload] input&#39;);</code></pre><p>就把选择范围限定在<code>name</code>属性为<code>upload</code>的表单里。如果页面有很多表单，其他表单的<code>&lt;input&gt;</code>不会被选择。</p>
<p>多层选择也是允许的：</p>
<pre><code>$(&#39;form.test p input&#39;); // 在form表单选择被&lt;p&gt;包含的&lt;input&gt;</code></pre><h4 id="子选择器（Child-Selector）"><a href="#子选择器（Child-Selector）" class="headerlink" title="子选择器（Child Selector）"></a>子选择器（Child Selector）</h4><p>子选择器<code>$(&#39;parent&gt;child&#39;)</code>类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。还是以上面的例子：</p>
<pre><code>$(&#39;ul.lang&gt;li.lang-javascript&#39;); // 可以选出[&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]
$(&#39;div.testing&gt;li.lang-javascript&#39;); // [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系</code></pre><h4 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h4><p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果：</p>
<pre><code>$(&#39;ul.lang li&#39;); // 选出JavaScript、Python和Lua 3个节点

$(&#39;ul.lang li:first-child&#39;); // 仅选出JavaScript
$(&#39;ul.lang li:last-child&#39;); // 仅选出Lua
$(&#39;ul.lang li:nth-child(2)&#39;); // 选出第N个元素，N从1开始
$(&#39;ul.lang li:nth-child(even)&#39;); // 选出序号为偶数的元素
$(&#39;ul.lang li:nth-child(odd)&#39;); // 选出序号为奇数的元素</code></pre><h4 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h4><p>针对表单元素，jQuery还有一组特殊的选择器：</p>
<ul>
<li><code>:input</code>：可以选择<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;button&gt;</code>；</li>
<li><code>:file</code>：可以选择<code>&lt;input type=&quot;file&quot;&gt;</code>，和<code>input[type=file]</code>一样；</li>
<li><code>:checkbox</code>：可以选择复选框，和<code>input[type=checkbox]</code>一样；</li>
<li><code>:radio</code>：可以选择单选框，和<code>input[type=radio]</code>一样；</li>
<li><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个<code>&lt;input&gt;</code>上，用<code>$(&#39;input:focus&#39;)</code>就可以选出；</li>
<li><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$(&#39;input[type=radio]:checked&#39;)</code>；</li>
<li><code>:enabled</code>：可以选择可以正常输入的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 等，也就是没有灰掉的输入；</li>
<li><code>:disabled</code>：和<code>:enabled</code>正好相反，选择那些不能输入的。</li>
</ul>
<p>此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：</p>
<pre><code>$(&#39;div:visible&#39;); // 所有可见的div
$(&#39;div:hidden&#39;); // 所有隐藏的div</code></pre><h4 id="查找和过滤"><a href="#查找和过滤" class="headerlink" title="查找和过滤"></a>查找和过滤</h4><p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。</p>
<p>最常见的查找是在某个节点的所有子节点中查找，使用<code>find()</code>方法，它本身又接收一个任意的选择器。例如如下的HTML结构：</p>
<ul>
<li>JavaScript</li>
<li>Python</li>
<li>Swift</li>
<li>Scheme</li>
<li>Haskell</li>
</ul>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ul class=&quot;lang&quot;&gt;
    &lt;li class=&quot;js dy&quot;&gt;JavaScript&lt;/li&gt;
    &lt;li class=&quot;dy&quot;&gt;Python&lt;/li&gt;
    &lt;li id=&quot;swift&quot;&gt;Swift&lt;/li&gt;
    &lt;li class=&quot;dy&quot;&gt;Scheme&lt;/li&gt;
    &lt;li name=&quot;haskell&quot;&gt;Haskell&lt;/li&gt;
&lt;/ul&gt;</code></pre><p>用<code>find()</code>查找：</p>
<pre><code>var ul = $(&#39;ul.lang&#39;); // 获得&lt;ul&gt;
var dy = ul.find(&#39;.dy&#39;); // 获得JavaScript, Python, Scheme
var swf = ul.find(&#39;#swift&#39;); // 获得Swift
var hsk = ul.find(&#39;[name=haskell]&#39;); // 获得Haskell</code></pre><p>如果要从当前节点开始向上查找，使用<code>parent()</code>方法：</p>
<pre><code>var swf = $(&#39;#swift&#39;); // 获得Swift
var parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt;
var a = swf.parent(&#39;.red&#39;); // 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象</code></pre><p>对于位于同一层级的节点，可以通过<code>next()</code>和<code>prev()</code>方法，例如：</p>
<p>当我们已经拿到<code>Swift</code>节点后：</p>
<pre><code>var swift = $(&#39;#swift&#39;);

swift.next(); // Scheme
swift.next(&#39;[name=haskell]&#39;); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]

swift.prev(); // Python
swift.prev(&#39;.dy&#39;); // Python，因为Python同时符合过滤器条件.dy</code></pre><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>和函数式编程的map、filter类似，jQuery对象也有类似的方法。</p>
<p><code>filter()</code>方法可以过滤掉不符合选择器条件的节点：</p>
<pre><code>var langs = $(&#39;ul.lang li&#39;); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var a = langs.filter(&#39;.dy&#39;); // 拿到JavaScript, Python, Scheme</code></pre><p>或者传入一个函数，要特别注意函数内部的<code>this</code>被绑定为DOM对象，不是jQuery对象：</p>
<pre><code>var langs = $(&#39;ul.lang li&#39;); // 拿到JavaScript, Python, Swift, Scheme和Haskell
langs.filter(function () {
    return this.innerHTML.indexOf(&#39;S&#39;) === 0; // 返回S开头的节点
}); // 拿到Swift, Scheme</code></pre><p><code>map()</code>方法把一个jQuery对象包含的若干DOM节点转化为其他对象：</p>
<pre><code>var langs = $(&#39;ul.lang li&#39;); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var arr = langs.map(function () {
    return this.innerHTML;
}).get(); // 用get()拿到包含string的Array：[&#39;JavaScript&#39;, &#39;Python&#39;, &#39;Swift&#39;, &#39;Scheme&#39;, &#39;Haskell&#39;]</code></pre><p>此外，一个jQuery对象如果包含了不止一个DOM节点，<code>first()</code>、<code>last()</code>和<code>slice()</code>方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉：</p>
<pre><code>var langs = $(&#39;ul.lang li&#39;); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var js = langs.first(); // JavaScript，相当于$(&#39;ul.lang li:first-child&#39;)
var haskell = langs.last(); // Haskell, 相当于$(&#39;ul.lang li:last-child&#39;)
var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致</code></pre><h3 id="操作DOM-1"><a href="#操作DOM-1" class="headerlink" title="操作DOM"></a>操作DOM</h3><h4 id="修改Text和HTML"><a href="#修改Text和HTML" class="headerlink" title="修改Text和HTML"></a>修改Text和HTML</h4><p>jQuery对象的<code>text()</code>和<code>html()</code>方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ul id=&quot;test-ul&quot;&gt;
    &lt;li class=&quot;js&quot;&gt;JavaScript&lt;/li&gt;
    &lt;li name=&quot;book&quot;&gt;Java &amp;amp; JavaScript&lt;/li&gt;
&lt;/ul&gt;</code></pre><p>分别获取文本和HTML：</p>
<pre><code>$(&#39;#test-ul li[name=book]&#39;).text(); // &#39;Java &amp; JavaScript&#39;
$(&#39;#test-ul li[name=book]&#39;).html(); // &#39;Java &amp;amp; JavaScript&#39;</code></pre><p>如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用<code>text()</code>是获取文本，传入参数就变成设置文本，HTML也是类似操作，自己动手试试：</p>
<pre><code>&#39;use strict&#39;; var j1 = $(&#39;#test-ul li.js&#39;);
var j2 = $(&#39;#test-ul li[name=book]&#39;);</code></pre><pre><code>j1.html(&#39;&lt;span style=&quot;color: red&quot;&gt;JavaScript&lt;/span&gt;&#39;);
j2.text(&#39;JavaScript &amp; ECMAScript&#39;);</code></pre><p>一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试：</p>
<pre><code>$(&#39;#test-ul li&#39;).text(&#39;JS&#39;); // 是不是两个节点都变成了JS？</code></pre><p>所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错：</p>
<pre><code>// 如果不存在id为not-exist的节点：
$(&#39;#not-exist&#39;).text(&#39;Hello&#39;); // 代码不报错，没有节点被设置为&#39;Hello&#39;</code></pre><p>这意味着jQuery帮你免去了许多<code>if</code>语句。</p>
<p><em>注意</em>，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。</p>
<p>jQuery对象的<code>css()</code>方法可以这么用：</p>
<pre><code>var div = $(&#39;#test-div&#39;);
div.css(&#39;color&#39;); // &#39;#000033&#39;, 获取CSS属性
div.css(&#39;color&#39;, &#39;#336699&#39;); // 设置CSS属性
div.css(&#39;color&#39;, &#39;&#39;); // 清除CSS属性</code></pre><p>为了和JavaScript保持一致，CSS属性可以用<code>&#39;background-color&#39;</code>和<code>&#39;backgroundColor&#39;</code>两种格式。</p>
<p><code>css()</code>方法将作用于DOM节点的<code>style</code>属性，具有最高优先级。如果要修改<code>class</code>属性，可以用jQuery提供的下列方法：</p>
<pre><code>var div = $(&#39;#test-div&#39;);
div.hasClass(&#39;highlight&#39;); // false， class是否包含highlight
div.addClass(&#39;highlight&#39;); // 添加highlight这个class
div.removeClass(&#39;highlight&#39;); // 删除highlight这个class</code></pre><h4 id="显示和隐藏DOM"><a href="#显示和隐藏DOM" class="headerlink" title="显示和隐藏DOM"></a>显示和隐藏DOM</h4><p>要隐藏一个DOM，我们可以设置CSS的<code>display</code>属性为<code>none</code>，利用<code>css()</code>方法就可以实现。不过，要显示这个DOM就需要恢复原有的<code>display</code>属性，这就得先记下来原有的<code>display</code>属性到底是<code>block</code>还是<code>inline</code>还是别的值。</p>
<p>考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供<code>show()</code>和<code>hide()</code>方法，我们不用关心它是如何修改<code>display</code>属性的，总之它能正常工作：</p>
<pre><code>var a = $(&#39;a[target=_blank]&#39;);
a.hide(); // 隐藏
a.show(); // 显示</code></pre><p><em>注意</em>，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。</p>
<h4 id="获取DOM信息"><a href="#获取DOM信息" class="headerlink" title="获取DOM信息"></a>获取DOM信息</h4><p>利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码：</p>
<pre><code>// 浏览器可视窗口大小:
$(window).width(); // 800
$(window).height(); // 600

// HTML文档大小:
$(document).width(); // 800
$(document).height(); // 3500

// 某个div的大小:
var div = $(&#39;#test-div&#39;);
div.width(); // 600
div.height(); // 300
div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效
div.height(&#39;200px&#39;); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效</code></pre><p><code>attr()</code>和<code>removeAttr()</code>方法用于操作DOM节点的属性：</p>
<pre><code>// &lt;div id=&quot;test-div&quot; name=&quot;Test&quot; start=&quot;1&quot;&gt;...&lt;/div&gt;
var div = $(&#39;#test-div&#39;);
div.attr(&#39;data&#39;); // undefined, 属性不存在
div.attr(&#39;name&#39;); // &#39;Test&#39;
div.attr(&#39;name&#39;, &#39;Hello&#39;); // div的name属性变为&#39;Hello&#39;
div.removeAttr(&#39;name&#39;); // 删除name属性
div.attr(&#39;name&#39;); // undefined</code></pre><p><code>prop()</code>方法和<code>attr()</code>类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如：</p>
<pre><code>&lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked value=&quot;1&quot;&gt;</code></pre><p>等价于：</p>
<pre><code>&lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked=&quot;checked&quot; value=&quot;1&quot;&gt;</code></pre><p><code>attr()</code>和<code>prop()</code>对于属性<code>checked</code>处理有所不同：</p>
<pre><code>var radio = $(&#39;#test-radio&#39;);
radio.attr(&#39;checked&#39;); // &#39;checked&#39;
radio.prop(&#39;checked&#39;); // true</code></pre><p><code>prop()</code>返回值更合理一些。不过，用<code>is()</code>方法判断更好：</p>
<pre><code>var radio = $(&#39;#test-radio&#39;);
radio.is(&#39;:checked&#39;); // true</code></pre><p>类似的属性还有<code>selected</code>，处理时最好用<code>is(&#39;:selected&#39;)</code>。</p>
<h4 id="操作表单-1"><a href="#操作表单-1" class="headerlink" title="操作表单"></a>操作表单</h4><p>对于表单元素，jQuery对象统一提供<code>val()</code>方法获取和设置对应的<code>value</code>属性：</p>
<pre><code>/*
    &lt;input id=&quot;test-input&quot; name=&quot;email&quot; value=&quot;&quot;&gt;
    &lt;select id=&quot;test-select&quot; name=&quot;city&quot;&gt;
        &lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt;
        &lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt;
        &lt;option value=&quot;SZ&quot;&gt;Shenzhen&lt;/option&gt;
    &lt;/select&gt;
    &lt;textarea id=&quot;test-textarea&quot;&gt;Hello&lt;/textarea&gt;
*/
var
    input = $(&#39;#test-input&#39;),
    select = $(&#39;#test-select&#39;),
    textarea = $(&#39;#test-textarea&#39;);

input.val(); // &#39;test&#39;
input.val(&#39;abc@example.com&#39;); // 文本框的内容已变为abc@example.com

select.val(); // &#39;BJ&#39;
select.val(&#39;SH&#39;); // 选择框已变为Shanghai

textarea.val(); // &#39;Hello&#39;
textarea.val(&#39;Hi&#39;); // 文本区域已更新为&#39;Hi&#39;</code></pre><p>可见，一个<code>val()</code>就统一了各种输入框的取值和赋值的问题。</p>
<h4 id="修改DOM结构"><a href="#修改DOM结构" class="headerlink" title="修改DOM结构"></a>修改DOM结构</h4><h5 id="添加DOM"><a href="#添加DOM" class="headerlink" title="添加DOM"></a>添加DOM</h5><p>要添加新的DOM节点，除了通过jQuery的<code>html()</code>这种暴力方法外，还可以用<code>append()</code>方法，例如：</p>
<pre><code>&lt;div id=&quot;test-div&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre><p>如何向列表新增一个语言？首先要拿到<code>&lt;ul&gt;</code>节点：</p>
<pre><code>var ul = $(&#39;#test-div&gt;ul&#39;);</code></pre><p>然后，调用<code>append()</code>传入HTML片段：</p>
<pre><code>ul.append(&#39;&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;&#39;);</code></pre><p>除了接受字符串，<code>append()</code>还可以传入原始的DOM对象，jQuery对象和函数对象：</p>
<pre><code>// 创建DOM对象:
var ps = document.createElement(&#39;li&#39;);
ps.innerHTML = &#39;&lt;span&gt;Pascal&lt;/span&gt;&#39;;
// 添加DOM对象:
ul.append(ps);

// 添加jQuery对象:
ul.append($(&#39;#scheme&#39;));

// 添加函数对象:
ul.append(function (index, html) {
    return &#39;&lt;li&gt;&lt;span&gt;Language - &#39; + index + &#39;&lt;/span&gt;&lt;/li&gt;&#39;;
});</code></pre><p>传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的<code>append()</code>可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。</p>
<p><code>append()</code>把DOM添加到最后，<code>prepend()</code>则把DOM添加到最前。</p>
<p>另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用<code>append()</code>，你可以移动一个DOM节点。</p>
<p>如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用<code>after()</code>方法：</p>
<pre><code>var js = $(&#39;#test-div&gt;ul&gt;li:first-child&#39;);
js.after(&#39;&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;&#39;);</code></pre><p>也就是说，同级节点可以用<code>after()</code>或者<code>before()</code>方法。</p>
<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>要删除DOM节点，拿到jQuery对象后直接调用<code>remove()</code>方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：</p>
<pre><code>var li = $(&#39;#test-div&gt;ul&gt;li&#39;);
li.remove(); // 所有&lt;li&gt;全被删除</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。</p>
<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个<code>click</code>事件：</p>
<pre><code>/* HTML:
 *
 * &lt;a id=&quot;test-link&quot; href=&quot;#0&quot;&gt;点我试试&lt;/a&gt;
 *
 */

// 获取超链接的jQuery对象:
var a = $(&#39;#test-link&#39;);
a.on(&#39;click&#39;, function () {
    alert(&#39;Hello!&#39;);
});</code></pre><p><code>on</code>方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。</p>
<p>另一种更简化的写法是直接调用<code>click()</code>方法：</p>
<pre><code>a.click(function () {
    alert(&#39;Hello!&#39;);
});</code></pre><p>jQuery能够绑定的事件主要包括：</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li>click: 鼠标单击时触发；</li>
<li>dblclick：鼠标双击时触发；</li>
<li>mouseenter：鼠标进入时触发；</li>
<li>mouseleave：鼠标移出时触发；</li>
<li>mousemove：鼠标在DOM内部移动时触发；</li>
<li>hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。</li>
</ul>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>键盘事件仅作用在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>。</p>
<ul>
<li>keydown：键盘按下时触发；</li>
<li>keyup：键盘松开时触发；</li>
<li>keypress：按一次键后触发。</li>
</ul>
<h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ul>
<li>focus：当DOM获得焦点时触发；</li>
<li>blur：当DOM失去焦点时触发；</li>
<li>change：当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>或<code>&lt;textarea&gt;</code>的内容改变时触发；</li>
<li>submit：当<code>&lt;form&gt;</code>提交时触发；</li>
<li>ready：当页面被载入并且DOM树完成初始化后触发。</li>
</ul>
<p>其中，<code>ready</code>仅作用于<code>document</code>对象。由于<code>ready</code>事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个<code>&lt;form&gt;</code>表单绑定<code>submit</code>事件，下面的代码没有预期的效果：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        // 代码有误:
        $(&#39;#testForm).on(&#39;submit&#39;, function () {
            alert(&#39;submit!&#39;);
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;testForm&quot;&gt;
        ...
    &lt;/form&gt;
&lt;/body&gt;</code></pre><p>因为JavaScript在此执行的时候，<code>&lt;form&gt;</code>尚未载入浏览器，所以<code>$(&#39;#testForm)</code>返回<code>[]</code>，并没有绑定事件到任何DOM上。</p>
<p>所以我们自己的初始化代码必须放到<code>document</code>对象的<code>ready</code>事件中，保证DOM已完成初始化：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        $(document).on(&#39;ready&#39;, function () {
            $(&#39;#testForm).on(&#39;submit&#39;, function () {
                alert(&#39;submit!&#39;);
            });
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;testForm&quot;&gt;
        ...
    &lt;/form&gt;
&lt;/body&gt;</code></pre><p>这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。</p>
<p>由于<code>ready</code>事件使用非常普遍，所以可以这样简化：</p>
<pre><code>$(document).ready(function () {
    // on(&#39;submit&#39;, function)也可以简化:
    $(&#39;#testForm).submit(function () {
        alert(&#39;submit!&#39;);
    });
});</code></pre><p>甚至还可以再简化为：</p>
<pre><code>$(function () {
    // init...
});</code></pre><p>上面的这种写法最为常见。如果你遇到<code>$(function () {...})</code>的形式，牢记这是<code>document</code>对象的<code>ready</code>事件处理函数。</p>
<p>完全可以反复绑定事件处理函数，它们会依次执行：</p>
<pre><code>$(function () {
    console.log(&#39;init A...&#39;);
});
$(function () {
    console.log(&#39;init B...&#39;);
});
$(function () {
    console.log(&#39;init C...&#39;);
});</code></pre><h3 id="取消绑定"><a href="#取消绑定" class="headerlink" title="取消绑定"></a>取消绑定</h3><p>一个已被绑定的事件可以解除绑定，通过<code>off(&#39;click&#39;, function)</code>实现：</p>
<pre><code>function hello() {
    alert(&#39;hello!&#39;);
}

a.click(hello); // 绑定事件

// 10秒钟后解除绑定:
setTimeout(function () {
    a.off(&#39;click&#39;, hello);
}, 10000);</code></pre><p>需要特别注意的是，下面这种写法是无效的：</p>
<pre><code>// 绑定事件:
a.click(function () {
    alert(&#39;hello!&#39;);
});

// 解除绑定:
a.off(&#39;click&#39;, function () {
    alert(&#39;hello!&#39;);
});</code></pre><p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个<em>不同</em>的函数对象，<code>off(&#39;click&#39;, function () {...})</code>无法移除已绑定的第一个匿名函数。</p>
<p>为了实现移除效果，可以使用<code>off(&#39;click&#39;)</code>一次性移除已绑定的<code>click</code>事件的所有处理函数。</p>
<p>同理，无参数调用<code>off()</code>一次性移除已绑定的所有类型的事件处理函数。</p>
<h5 id="事件触发条件"><a href="#事件触发条件" class="headerlink" title="事件触发条件"></a>事件触发条件</h5><p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：</p>
<pre><code>var input = $(&#39;#test-input&#39;);
input.change(function () {
    console.log(&#39;changed...&#39;);
});</code></pre><p>当用户在文本框中输入时，就会触发<code>change</code>事件。但是，如果用JavaScript代码去改动文本框的值，将<em>不会</em>触发<code>change</code>事件：</p>
<pre><code>var input = $(&#39;#test-input&#39;);
input.val(&#39;change it!&#39;); // 无法触发change事件</code></pre><p>有些时候，我们希望用代码触发<code>change</code>事件，可以直接调用无参数的<code>change()</code>方法来触发该事件：</p>
<pre><code>var input = $(&#39;#test-input&#39;);
input.val(&#39;change it!&#39;);
input.change(); // 触发change事件</code></pre><p><code>input.change()</code>相当于<code>input.trigger(&#39;change&#39;)</code>，它是<code>trigger()</code>方法的简写。</p>
<p>为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。</p>
<h5 id="浏览器安全限制"><a href="#浏览器安全限制" class="headerlink" title="浏览器安全限制"></a>浏览器安全限制</h5><p>在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，<code>window.open()</code>函数：</p>
<pre><code>// 无法弹出新窗口，将被浏览器屏蔽:
$(function () {
    window.open(&#39;/&#39;);
});</code></pre><p>这些“敏感代码”只能由用户操作来触发：</p>
<pre><code>var button1 = $(&#39;#testPopupButton1&#39;);
var button2 = $(&#39;#testPopupButton2&#39;);

function popupTestWindow() {
    window.open(&#39;/&#39;);
}

button1.click(function () {
    popupTestWindow();
});

button2.click(function () {
    // 不立刻执行popupTestWindow()，3秒后执行:
    setTimeout(popupTestWindow, 3000);
});</code></pre><p>当用户点击<code>button1</code>时，<code>click</code>事件被触发，由于<code>popupTestWindow()</code>在<code>click</code>事件处理函数内执行，这是浏览器允许的，而<code>button2</code>的<code>click</code>事件并未立刻执行<code>popupTestWindow()</code>，延迟执行的<code>popupTestWindow()</code>将被浏览器拦截。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。</p>
<p>但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>
<p>使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！</p>
<p>让我们先来看看jQuery内置的几种动画样式：</p>
<h3 id="show-hide"><a href="#show-hide" class="headerlink" title="show / hide"></a>show / hide</h3><p>直接以无参数形式调用<code>show()</code>和<code>hide()</code>，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画：</p>
<pre><code>var div = $(&#39;#test-show-hide&#39;);
div.hide(3000); // 在3秒钟内逐渐消失</code></pre><p>时间以毫秒为单位，但也可以是<code>&#39;slow&#39;</code>，<code>&#39;fast&#39;</code>这些字符串：</p>
<pre><code>var div = $(&#39;#test-show-hide&#39;);
div.show(&#39;slow&#39;); // 在0.6秒钟内逐渐显示</code></pre><p><code>toggle()</code>方法则根据当前状态决定是<code>show()</code>还是<code>hide()</code>。</p>
<p>你可能已经看出来了，<code>show()</code>和<code>hide()</code>是从左上角逐渐展开或收缩的，而<code>slideUp()</code>和<code>slideDown()</code>则是在垂直方向逐渐展开或收缩的。</p>
<p><code>slideUp()</code>把一个可见的DOM元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code>相反，而<code>slideToggle()</code>则根据元素是否可见来决定下一步动作：</p>
<pre><code>var div = $(&#39;#test-slide&#39;);
div.slideUp(3000); // 在3秒钟内逐渐向上消失</code></pre><h3 id="fadeIn-fadeOut"><a href="#fadeIn-fadeOut" class="headerlink" title="fadeIn / fadeOut"></a>fadeIn / fadeOut</h3><p><code>fadeIn()</code>和<code>fadeOut()</code>的动画效果是淡入淡出，也就是通过不断设置DOM元素的<code>opacity</code>属性来实现，而<code>fadeToggle()</code>则根据元素是否可见来决定下一步动作：</p>
<pre><code>var div = $(&#39;#test-fade&#39;);
div.fadeOut(&#39;slow&#39;); // 在0.6秒内淡出</code></pre><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>如果上述动画效果还不能满足你的要求，那就祭出最后大招：<code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值：</p>
<pre><code>var div = $(&#39;#test-animate&#39;);
div.animate({
    opacity: 0.25,
    width: &#39;256px&#39;,
    height: &#39;256px&#39;
}, 3000); // 在3秒钟内CSS过渡到设定值</code></pre><p><code>animate()</code>还可以再传入一个函数，当动画结束时，该函数将被调用：</p>
<pre><code>var div = $(&#39;#test-animate&#39;);
div.animate({
    opacity: 0.25,
    width: &#39;256px&#39;,
    height: &#39;256px&#39;
}, 3000, function () {
    console.log(&#39;动画已结束&#39;);
    // 恢复至初始状态:
    $(this).css(&#39;opacity&#39;, &#39;1.0&#39;).css(&#39;width&#39;, &#39;128px&#39;).css(&#39;height&#39;, &#39;128px&#39;);
});</code></pre><p>实际上这个回调函数参数对于基本动画也是适用的。</p>
<h4 id="串行动画"><a href="#串行动画" class="headerlink" title="串行动画"></a>串行动画</h4><p>jQuery的动画效果还可以串行执行，通过<code>delay()</code>方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单：</p>
<pre><code>var div = $(&#39;#test-animates&#39;);
// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小
div.slideDown(2000)
   .delay(1000)
   .animate({
       width: &#39;256px&#39;,
       height: &#39;256px&#39;
   }, 2000)
   .delay(1000)
   .animate({
       width: &#39;128px&#39;,
       height: &#39;128px&#39;
   }, 2000);
}
&lt;/script&gt;</code></pre><p>因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>
<h4 id="为什么有的动画没有效果"><a href="#为什么有的动画没有效果" class="headerlink" title="为什么有的动画没有效果"></a>为什么有的动画没有效果</h4><p>你可能会遇到，有的动画如<code>slideUp()</code>根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如<code>height</code>从<code>100px</code>逐渐变为<code>0</code>。但是很多不是block性质的DOM元素，对它们设置<code>height</code>根本就不起作用，所以动画也就没有效果。</p>
<p>此外，jQuery也没有实现对<code>background-color</code>的动画效果，用<code>animate()</code>设置<code>background-color</code>也没有效果。这种情况下可以使用CSS3的<code>transition</code>实现动画效果。</p>
<h3 id="AJAX-1"><a href="#AJAX-1" class="headerlink" title="AJAX"></a>AJAX</h3><p>jQuery在全局对象<code>jQuery</code>（也就是<code>$</code>）绑定了<code>ajax()</code>函数，可以处理AJAX请求。<code>ajax(url, settings)</code>函数需要接收一个URL和一个可选的<code>settings</code>对象，常用的选项如下：</p>
<ul>
<li>async：是否异步执行AJAX请求，默认为<code>true</code>，千万不要指定为<code>false</code>；</li>
<li>method：发送的Method，缺省为<code>&#39;GET&#39;</code>，可指定为<code>&#39;POST&#39;</code>、<code>&#39;PUT&#39;</code>等；</li>
<li>contentType：发送POST请求的格式，默认值为<code>&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</code>，也可以指定为<code>text/plain</code>、<code>application/json</code>；</li>
<li>data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；</li>
<li>headers：发送的额外的HTTP头，必须是一个object；</li>
<li>dataType：接收的数据格式，可以指定为<code>&#39;html&#39;</code>、<code>&#39;xml&#39;</code>、<code>&#39;json&#39;</code>、<code>&#39;text&#39;</code>等，缺省情况下根据响应的<code>Content-Type</code>猜测。</li>
</ul>
<p>下面的例子发送一个GET请求，并返回一个JSON格式的数据：</p>
<pre><code>var jqxhr = $.ajax(&#39;/api/categories&#39;, {
    dataType: &#39;json&#39;
});
// 请求已经发送了</code></pre><p>不过，如何用回调函数处理返回的数据和出错时的响应呢？</p>
<p>还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调：</p>
<pre><code>&#39;use strict&#39;;

function ajaxLog(s) {
    var txt = $(&#39;#test-response-text&#39;);
    txt.val(txt.val() + &#39;\n&#39; + s);
}

$(&#39;#test-response-text&#39;).val(&#39;&#39;);</code></pre><pre><code>var jqxhr = $.ajax(&#39;/api/categories&#39;, {
    dataType: &#39;json&#39;
}).done(function (data) {
    ajaxLog(&#39;成功, 收到的数据: &#39; + JSON.stringify(data));
}).fail(function (xhr, status) {
    ajaxLog(&#39;失败: &#39; + xhr.status + &#39;, 原因: &#39; + status);
}).always(function () {
    ajaxLog(&#39;请求完成: 无论成功或失败都会调用&#39;);
});</code></pre><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了<code>get()</code>方法，可以这么写：</p>
<pre><code>var jqxhr = $.get(&#39;/path/to/resource&#39;, {
    name: &#39;Bob Lee&#39;,
    check: 1
});</code></pre><p>第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：</p>
<pre><code>/path/to/resource?name=Bob%20Lee&amp;check=1</code></pre><p>这样我们就不用关心如何用URL编码并构造一个query string了。</p>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><code>post()</code>和<code>get()</code>类似，但是传入的第二个参数默认被序列化为<code>application/x-www-form-urlencoded</code>：</p>
<pre><code>var jqxhr = $.post(&#39;/path/to/resource&#39;, {
    name: &#39;Bob Lee&#39;,
    check: 1
});</code></pre><p>实际构造的数据<code>name=Bob%20Lee&amp;check=1</code>作为POST的body被发送。</p>
<h4 id="getJSON"><a href="#getJSON" class="headerlink" title="getJSON"></a>getJSON</h4><p>由于JSON用得越来越普遍，所以jQuery也提供了<code>getJSON()</code>方法来快速通过GET获取一个JSON对象：</p>
<pre><code>var jqxhr = $.getJSON(&#39;/path/to/resource&#39;, {
    name: &#39;Bob Lee&#39;,
    check: 1
}).done(function (data) {
    // data已经被解析为JSON对象了
});</code></pre><p>jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。</p>
<p>如果需要使用JSONP，可以在<code>ajax()</code>中设置<code>jsonp: &#39;callback&#39;</code>，让jQuery实现JSONP跨域加载数据。</p>
<p>关于跨域的设置请参考<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022129105888" target="_blank" rel="noopener">浏览器</a> - <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400" target="_blank" rel="noopener">AJAX</a>一节中CORS的设置。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。</p>
<p>但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现：</p>
<pre><code>$(&#39;span.hl&#39;).css(&#39;backgroundColor&#39;, &#39;#fffceb&#39;).css(&#39;color&#39;, &#39;#d85030&#39;);

$(&#39;p a.hl&#39;).css(&#39;backgroundColor&#39;, &#39;#fffceb&#39;).css(&#39;color&#39;, &#39;#d85030&#39;);</code></pre><p>总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个<code>highlight()</code>方法？</p>
<pre><code>$(&#39;span.hl&#39;).highlight();

$(&#39;p a.hl&#39;).highlight();</code></pre><p>答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。</p>
<p>最终，我们得出编写一个jQuery插件的原则：</p>
<ol>
<li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑；</li>
<li>插件函数最后要<code>return this;</code>以支持链式调用；</li>
<li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>上；</li>
<li>用户在调用时可传入设定值以便覆盖默认值。</li>
</ol>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h2 id="underscore"><a href="#underscore" class="headerlink" title="underscore"></a>underscore</h2>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com" rel="external nofollow noreferrer">梅海迪</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com/2020/051618006.html">http://yoursite.com/2020/051618006.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://yoursite.com" target="_blank">梅海迪</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/051661781.html">
                    <div class="card-image">
                        
                        
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/featureimages/5.jpg" class="responsive-img" alt="POI和easyExcel">
                        
                        <span class="card-title">POI和easyExcel</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            POI和easyExcel
常用场景

1，将用户信息导出为excel表格
2，将excel表格中的信息录入到网站数据库

Apache POI

Apache POI官网：https://poi.apache.org/ 



easyE
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-05-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            梅海迪
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/051614457.html">
                    <div class="card-image">
                        
                        
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/featureimages/19.jpg" class="responsive-img" alt="Elasticsearch">
                        
                        <span class="card-title">Elasticsearch</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ElasticSearch 安装声明:jdk1.8最低要求

window安装

1, 解压就可以用了
2,熟悉目录
bin 启动文件 
config 配置文件 
log4j2 日志配置文件 
jvm.options java 虚拟机相关的
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            梅海迪
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('50')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: CR553<br />'
            + '文章作者: 梅海迪<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="http://yoursite.com" target="_blank">梅海迪</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/CR553?tab=repositories" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:960162212@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=960162212" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 960162212" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>
